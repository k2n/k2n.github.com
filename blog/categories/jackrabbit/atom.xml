<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jackrabbit | Code Critique]]></title>
  <link href="http://k2n.github.com/blog/categories/jackrabbit/atom.xml" rel="self"/>
  <link href="http://k2n.github.com/"/>
  <updated>2012-06-19T16:13:57-07:00</updated>
  <id>http://k2n.github.com/</id>
  <author>
    <name><![CDATA[Kenji Nakamura]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XSD 2 CND Converter]]></title>
    <link href="http://k2n.github.com/blog/2012/06/01/xsd-2-cnd-converter/"/>
    <updated>2012-06-01T14:36:00-07:00</updated>
    <id>http://k2n.github.com/blog/2012/06/01/xsd-2-cnd-converter</id>
    <content type="html"><![CDATA[<p>JCRのNode Type Definitionを見ていると、XML Schemaと似ている点が多い。JCRが提供している階層構造のストレージはXMLの永続化に適していることが予想される。</p>

<p>となると、XML SchemaをCNDに変換できるのではないだろうかという予想のもと、調べてみると、Jackrabbitプロジェクトのコードベースの一部に、<a href="http://svn.apache.org/repos/asf/jackrabbit/sandbox/inactive/xsd2cnd/">xsd2cnd</a>というツールがあることがわかった。但し、このツールはJackrabbitの本流ではなく、sandbox、しかもinactiveの下に格納されていることから、長いことメンテされていない状況である。2008年に<code>sandbox/inactive</code>に移動されており、それ以来コードの更新がない。</p>

<p>確認のためローカルにダウンロードしてみると、なんとmavenがバージョン1である。懐かしい。maven2以降で動作させるためには、<code>project.xml</code>と<code>project.properties</code>を<code>pom.xml</code>に変換する必要がある。幸い、変換ツールが提供されている。
<code>
$ mvn2 one:convert
</code>
maven3ではもはや提供されていないようなので、maven2を使う必要がある。</p>

<p>動くように<a href="https://github.com/diva-america/xsd2cnd">ハック</a>して、XSDを変換してみたが、期待していた結果が得られなかった。このままでは使えず、改善が必要なようである。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JCR Node Types]]></title>
    <link href="http://k2n.github.com/blog/2012/05/31/jcr-node-types/"/>
    <updated>2012-05-31T16:51:00-07:00</updated>
    <id>http://k2n.github.com/blog/2012/05/31/jcr-node-types</id>
    <content type="html"><![CDATA[<h1>JCRノードタイプ</h1>

<p>JCRコンテンツはノードとプロパティで構成される。ノードにはタイプ情報をもたせずに（=スキーマレス）格納することができる。その際のノードタイプは<code>nt:unstructured</code>である。一方、格納する情報に規約を与えたい場合は、ノードタイプを定義し、格納する情報がスキーマに合致していることを保証することで、プログラムからのアクセスを容易にするとともに情報の整合性を向上させることができる。</p>

<p>JCRは標準のノードタイプを定義している。本稿ではそれらについて解説する。</p>

<h1>CND (Compact Namespace and Node Type Definition)</h1>

<p>JCRのノードタイプ情報はXMLで表現することは可能であるが、boolean属性が多いため、冗長性が大きい。ノードタイプ情報をコンパクトに記述するため、CND記法が定義されている。</p>

<p>``` text CND文法 (EBNF記法)
 Cnd ::= {NamespaceMapping | NodeTypeDef}  // どちらかの要素の0個以上の繰り返し
 NamespaceMapping ::= '&lt;' Prefix '=' Uri '>'
 Prefix ::= String
 Uri ::= String
 NodeTypeDef ::= NodeTypeName [Supertypes] // 角括弧はオプショナルであることを示す</p>

<pre><code>             [NodeTypeAttribute {NodeTypeAttribute}] // 中括弧は0個以上の繰り返し
             {PropertyDef | ChildNodeDef} // どちらかの0個以上の繰り返し
</code></pre>

<p> NodeTypeName ::= '[' String ']'
 Supertypes ::= '>' (StringList | '?')
 NodeTypeAttribute ::= Orderable | Mixin | Abstract | Query | //OrderableはJCR2.0 23参照のこと</p>

<pre><code>                   PrimaryItem
</code></pre>

<p> Orderable ::= ('orderable' | 'ord' | 'o') ['?']
 Mixin ::= ('mixin' | 'mix' | 'm') ['?']
 Abstract ::= ('abstract' | 'abs' | 'a') ['?']
 Query ::= ('noquery' | 'nq') | ('query' | 'q' )
 PrimaryItem ::= ('primaryitem'| '!')(String | '?')
 PropertyDef ::= PropertyName [PropertyType] [DefaultValues]</p>

<pre><code>             [PropertyAttribute {PropertyAttribute}]
             [ValueConstraints]
</code></pre>

<p> PropertyName ::= '-' String
 PropertyType ::= '(' ('STRING' | 'BINARY' | 'LONG' | 'DOUBLE' |</p>

<pre><code>                   'BOOLEAN' | 'DATE' | 'NAME' | 'PATH' |
                   'REFERENCE' | 'WEAKREFERENCE' |
                   'DECIMAL' | 'URI' | 'UNDEFINED' | '*' |
                   '?') ')'
</code></pre>

<p> DefaultValues ::= '=' (StringList | '?')
 ValueConstraints ::= '&lt;' (StringList | '?')
 ChildNodeDef ::= NodeName [RequiredTypes] [DefaultType]</p>

<pre><code>              [NodeAttribute {NodeAttribute}]
</code></pre>

<p> NodeName ::= '+' String
 RequiredTypes ::= '(' (StringList | '?') ')'
 DefaultType ::= '=' (String | '?')
 PropertyAttribute ::= Autocreated | Mandatory | Protected |</p>

<pre><code>                   Opv | Multiple | QueryOps | NoFullText |
                   NoQueryOrder
</code></pre>

<p> NodeAttribute ::= Autocreated | Mandatory | Protected |</p>

<pre><code>               Opv | Sns                              // Opv == On-Parent-Version 3.7.2.5 参照
                                                      // Sns == Same-name-Siblings 22 参照
</code></pre>

<p> Autocreated ::= ('autocreated' | 'aut' | 'a' )['?']
 Mandatory ::= ('mandatory' | 'man' | 'm') ['?']
 Protected ::= ('protected' | 'pro' | 'p') ['?']
 Opv ::= 'COPY' | 'VERSION' | 'INITIALIZE' | 'COMPUTE' |</p>

<pre><code>     'IGNORE' | 'ABORT' | ('OPV' '?')
</code></pre>

<p> Multiple ::= ('multiple' | 'mul' | '*') ['?']
 QueryOps ::= ('queryops' | 'qop')</p>

<pre><code>          (('''Operator {','Operator}''') | '?')
</code></pre>

<p> Operator ::= '=' | '&lt;>' | '&lt;' | '&lt;=' | '>' | '>=' | 'LIKE'
 NoFullText ::= ('nofulltext' | 'nof') ['?']
 NoQueryOrder ::= ('noqueryorder' | 'nqord') ['?']
 Sns ::= ('sns' | '*') ['?']
 StringList ::= String {',' String}
 String ::= QuotedString | UnquotedString
 QuotedString ::= SingleQuotedString | DoubleQuotedString
 SingleQuotedString ::= ''' UnquotedString '''
 DoubleQuotedString ::= '"' UnquotedString '"'
 UnquotedString ::= XmlChar {XmlChar}
 XmlChar ::= see 3.2.2 Local Names
```</p>

<h1>ベースタイプ</h1>

<h2>nt:base</h2>

<p><code>nt:base</code>は全てのプライマリノードタイプのベースとなる抽象プライマリノードタイプである。これだけがスーパータイプを持たないプライマリノードである。
<code>text
[nt:base]
  abstract
  - jcr:primaryType (NAME) mandatory autocreated protected COMPUTE
  - jcr:mixinTypes (NAME) protected multiple COMPUTE
</code></p>

<h1>標準アプリケーションノードタイプ</h1>

<h2>nt:hierarchyNode</h2>

<p><code>nt:folder</code>と<code>nt:file</code>のスーパータイプとして使われる抽象ノードタイプである。
<code>
[nt:hierarchyNode] &gt; mix:created
  abstract
</code></p>

<h2>nt:file</h2>

<p>ファイルを表すノードタイプ。<code>nt:hierarchyNode</code>を継承しており、<code>jcr:content</code>という子ノードをひとつ必須とする。<code>jcr:content</code>は実際のファイルの内容を保持するために用いられる。この子要素は必須ではあるが、自動生成はされない。そのノードタイプはアプリケーション次第であり、ユーザーによって指定されなければならないからである。一般的なアプローチとしては、<code>jcr:cotent</code>を<code>nt:resource</code>ノードタイプにするというものである。また、<code>jcr:content</code>は親ノード(=nt:file)のプライマリアイテムとして指定されている。
<code>
[nt:file] &gt; nt:hierarchyNode
  primaryitem jcr:content
  + jcr:content (nt:base) mandatory
</code></p>

<h2>nt:linkedFile</h2>

<p><code>nt:file</code>に類似しているが、コンテンツノードは子ノードとして直接格納されず、REFERENCEプロパティとして指定されている。これによりコンテンツノードがワークスペースのどこかよそに格納しておくことを可能にし、それを複数の<code>nt:linkedFile</code>ノードで参照することを可能にする。このコンテンツノードは参照可能でなければならない。
<code>
[nt:linkedFile] &gt; nt:hierarchyNode
  primaryitem jcr:content
  - jcr:content (REFERENCE) mandatory
</code></p>

<h2>nt:folder</h2>

<p>このノードタイプはフォルダ、あるいはディレクトリを表現するために用いることができる。このノードタイプは<code>nt:hierarchyNode</code>で定義されているアイテムを継承しており、他の<code>nt:hierarchyNode</code>を子ノードとしていくつでも取ることができる。具体的に言えば、<code>nt:folder</code>, <code>nt:file</code>, <code>nt:linkedFile</code>の子ノードを持つことができるということである。
<code>
[nt:folder] &gt; nt:hierarchyNode
  + * (nt:hierarchyNode) VERSION
</code></p>

<h2>nt:resource</h2>

<p>このノードタイプはファイルの内容を表すのに用いられる。特に、<code>nt:file</code>のサブノードである<code>jcr:content</code>はしばしば<code>nt:resource</code>となる。
<code>
[nt:resource] &gt; mix:mimeType, mix:lastModified, mix:referenceable
  primaryitem jcr:data
  - jcr:data (BINARY) mandatory
</code></p>

<h2>mix:title</h2>

<p>このmixinノードタイプは標準化されたタイトルと説明プロパティをノードに付加するために用いられる。
<code>
[mix:title]
  mixin
  - jcr:title (STRING)
  - jcr:description (STRING)
</code></p>

<h2>mix:created</h2>

<p>このmixinノードタイプは標準化された作成情報をノードに付与するために用いられる。これらのプロパティはprotectedされているため、値はリポジトリによって制御されており、このmixinタイプが付与されたノードが最初に永続化される時に情報が適宜設定される。既に存在するノードに対してこのmixinが付与された場合の振舞いは実装に依る。Jackrabbitの場合は現在の日付とユーザーでプロパティを初期化する。
<code>
[mix:created]
  mixin
  - jcr:created (DATE) autocreated protected
  - jcr:createdBy (STRING) autocreated protected
</code></p>

<h2>mix:lastModified</h2>

<p>このmixinノードタイプはノードに標準化された更新情報を付与するために用いることができる。
JCR2.0スペックでは、「このプロパティは保護されているため値はリポジトリによって制御されており、このmixinを持つノードのサブグラフにおいて重大な改変があった場合には適切に値を設定しなければならない。重大な改変に相当するものはノードのサブグラフの意味によるため、実装依存とする。」とあるが、この部分についてはJackrabbitではまだ実装されていない。</p>

<p>Jackrabbitはノードが新規作成された場合このプロパティを現在の日付とユーザーで初期化する。</p>

<p>JSR-283で提案されていた、このプロパティに対する保護属性はこのバージョンでは除外されていることに注意。</p>

<p><code>
[mix:lastModified]
  mixin
  - jcr:lastModified (DATE) autocreated
  - jcr:lastModifiedBy (STRING) autocreated
</code></p>

<h2>mix:language</h2>

<p>あるノードのコンテンツが表現する自然言語を指定するための標準化されたプロパティを提供する。<code>jcr:language</code>プロパティの値は<a href="http://tools.ietf.org/html/rfc5646">RFC5646</a>で指定された言語コードでなければいけない。例：<code>en</code>（英語）、"en-US"（米国英語）、"de"（ドイツ語）、"de-CH"（スイスドイツ語）
<code>
[mix:language]
  mixin
  - jcr:language (STRING)
</code></p>

<h2>mix:mimeType</h2>

<p>このmixinノードタイプはノードに対する標準化されたMIMEタイプとエンコーディングプロパティを提供するために用いられる。このタイプのノードが単値のBINARYプロパティのプライマリアイテムを持っている場合<code>jcr:mymeType</code>プロパティはそのメディアタイプがコンテンツに適用可能であり、かつそのメディアがテキストエンコーディングの適用が可能であるものの場合は、<code>jcr:encoding</code>プロパティが適用すべきキャラクタ・セット情報を示す。ノードが上記の条件を満たさない場合の解釈は実装に依存する。
<code>
[mix:mimeType]
  mixin
  - jcr:mimeType (STRING)
  - jcr:encoding (STRING)
</code></p>

<h2>nt:address</h2>

<p>このノードタイプは、特定のワークスペース内だけでなく、全てのJCRリポジトリの全てのワークスペース内にあるJCRアイテムの場所を表すことができる。<code>jcr:protocol</code>, <code>jcr:host</code>, <code>jcr:port</code>についてのセマンティクスは定義されておらず、アプリケーション側が理解できるものとする。</p>

<p>多くの場合、<code>jcr:path</code>か<code>jcr:id</code>のどちらかだけを用いて、この二つが違うノードを示すことを防ぐ。<code>jcr:path</code>と<code>jcr:id</code>以外のプロパティが欠けている場合、このアドレスは欠けているプロパティを現在いるレベルの値であるとして相対的に解釈する。例えば、もしリポジトリが指定されなければ現在のリポジトリ内での相対的なworkspaceとパスであると解釈される。
<code>
[nt:address]
  - jcr:protocol (STRING)
  - jcr:host (STRING)
  - jcr:port (STRING)
  - jcr:repository (STRING)
  - jcr:workspace (STRING)
  - jcr:path (PATH)
  - jcr:id (WEAKREFERENCE)
</code></p>

<h2>mix:etag</h2>

<p><code>mix:etag</code> mixinタイプはBINARYプロパティ用に標準化された、HTTP/1.1のentity tagと同様のアイデンティティ・バリデータを提供する。
<code>jcr:etag</code>はHTTP/1.1のentity tagsと同一の文法を持つ隠し文字列である。<code>mix:etag</code>を持つノードNを作成した際、リポジトリは<code>jcr:etag</code>プロパティに実装が決定した値をセットする。</p>

<p><code>jcr:etag</code>の値はNに下記の変更が加えられた際には即座に変更されることになっている。</p>

<ul>
<li>あるBINARYプロパティがNに追加される。</li>
<li>あるBINARYプロパティがNから削除される。</li>
<li>既存のBINARYプロパティの値が変更される。</li>
</ul>


<p><code>
[mix:etag]
  mixin
  - jcr:etag (STRING) protected autocreated
</code></p>

<h1>非構造化コンテンツ</h1>

<h2>nt:unstructured</h2>

<p>このノードタイプは非構造化コンテンツを格納するために用いられる。任意の名前のプロパティをいくつでも保持することができる。複数のノードが同名を取ることも可能であるし、あるプロパティが複数の値をとることも、１つの値を取ることも自由である。このノードタイプはクライアント側の順序付け子ノードもサポートしている。
<code>
[nt:unstructured]
  orderable
  - * (UNDEFINED) multiple
  - * (UNDEFINED)
  + * (nt:base) = nt:unstructured sns VERSION
</code></p>

<h1>参照</h1>

<h2>mix:referenceable</h2>

<p>このノードタイプは、自動生成で、必須、保護されたSTRINGプロパティ<code>jcr:uuid</code>をノードに付与する。これはノードの識別子として用いられる。”UUID"という語はJCR1.0への後方互換性のために用いられており、必ずしもUUID文法を使うことを意味してはいないことに注意。参照可能ノードの識別子は参照可能な識別子でなければならない。参照可能な識別子は標準の識別子に要求される要件いアギに様々な制約を満たしていなければならない。（詳細は3.8.3 参照可能識別子を参照）参照プロパティは参照可能ノードの参照可能識別子を持つプロパティであり、結果としてそのノードへのポインターとして用いられる。<code>REFERENCE</code>と<code>WEAKREFERENCE</code>は前者が参照整合性を必要とするのに対し後者は不要であるという点が異なる。
<code>
[mix:referenceable]
  mixin
  - jcr:uuid (STRING) mandatory autocreated protected INITIALIZE
</code></p>

<h1>ロッキング</h1>

<h2>mix:lockable</h2>

<p><code>
[mix:lockable]
  mixin
  - jcr:lockOwner (STRING) protected IGNORE
  - jcr:lockIsDeep (BOOLEAN) protected IGNORE
</code></p>

<h1>共有可能ノード</h1>

<h2>mix:shareable</h2>

<p><code>
[mix:shareable] &gt; mix:referenceable
  mixin
</code></p>

<h1>バージョニング</h1>

<h2>mix:simpleVersionable</h2>

<p><code>
[mix:simpleVersionable]
  mixin
  - jcr:isCheckedOut (BOOLEAN) = 'true' mandatory autocreated protected IGNORE
</code></p>

<h2>mix:versionable</h2>

<p>```
[mix:versionable] > mix:simpleVersionable, mix:referenceable
  mixin
  - jcr:versionHistory (REFERENCE) mandatory protected IGNORE &lt; 'nt:versionHistory'
  - jcr:baseVersion (REFERENCE) mandatory protected IGNORE &lt; 'nt:version'
  - jcr:predecessors (REFERENCE) mandatory protected multiple IGNORE &lt; 'nt:version'
  - jcr:mergeFailed (REFERENCE) protected multiple ABORT &lt; 'nt:version'</p>

<pre><code>/** @since 2.0 */
</code></pre>

<ul>
<li>jcr:activity (REFERENCE) protected &lt; 'nt:activity'
/<em>* @since 2.0 </em>/</li>
<li>jcr:configuration (REFERENCE) protected IGNORE &lt; 'nt:configuration'
```</li>
</ul>


<h2>nt:versionHistory</h2>

<p>```
[nt:versionHistory] > mix:referenceable
  - jcr:versionableUuid (STRING) mandatory autocreated protected ABORT</p>

<pre><code>/** @since 2.0 */
</code></pre>

<ul>
<li>jcr:copiedFrom (WEAKREFERENCE) protected ABORT &lt; 'nt:version'</li>
<li>jcr:rootVersion (nt:version) = nt:version mandatory autocreated protected ABORT</li>
<li>jcr:versionLabels (nt:versionLabels) = nt:versionLabels mandatory autocreated protected ABORT</li>
<li><ul>
<li>(nt:version) = nt:version protected ABORT
```</li>
</ul>
</li>
</ul>


<h2>nt:versionLables</h2>

<p>```
[nt:versionLabels]
  - * (REFERENCE) protected ABORT &lt; 'nt:version'
[nt:version] > mix:referenceable
  - jcr:created (DATE) mandatory autocreated protected ABORT
  - jcr:predecessors (REFERENCE) protected multiple ABORT &lt; 'nt:version'
  - jcr:successors (REFERENCE) protected multiple ABORT &lt; 'nt:version'</p>

<pre><code>/** @since 2.0 */
</code></pre>

<ul>
<li>jcr:activity (REFERENCE) protected ABORT &lt; 'nt:activity'</li>
<li>jcr:frozenNode (nt:frozenNode) protected ABORT
```</li>
</ul>


<h2>nt:frozenNode</h2>

<p><code>
[nt:frozenNode] &gt; mix:referenceable
  orderable
  - jcr:frozenPrimaryType (NAME) mandatory autocreated protected ABORT
  - jcr:frozenMixinTypes (NAME) protected multiple ABORT
  - jcr:frozenUuid (STRING) mandatory autocreated protected ABORT
  - * (UNDEFINED) protected ABORT
  - * (UNDEFINED) protected multiple ABORT
  + * (nt:base) protected sns ABORT
</code></p>

<h2>nt:versionChild</h2>

<p><code>
[nt:versionedChild]
  - jcr:childVersionHistory (REFERENCE) mandatory autocreated protected ABORT &lt; 'nt:versionHistory'
</code></p>

<h2>nt:activity</h2>

<p><code>
[nt:activity] &gt; mix:referenceable
  - jcr:activityTitle (STRING) mandatory autocreated protected
</code></p>

<h2>nt:configuration</h2>

<p><code>
[nt:configuration] &gt; mix:versionable
  - jcr:root (REFERENCE) mandatory autocreated protected
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jackrabbit OCM status]]></title>
    <link href="http://k2n.github.com/blog/2012/05/31/jackrabbit-ocm-status/"/>
    <updated>2012-05-31T15:16:00-07:00</updated>
    <id>http://k2n.github.com/blog/2012/05/31/jackrabbit-ocm-status</id>
    <content type="html"><![CDATA[<p>2012年5月末時点で最新のjackrabbit-ocmリリースは1.5.3である。Jackrabbit本体のバージョン(2.4.1)からは大きくかけ離れているが、これは、ocmはjakarta-commonsのサブプロジェクトとして、jackrabbit本体とは別のライフサイクルでリリースされているためである。OCMはJCRのみに依存しており、Jackrabbitの実装への依存性がほぼないことから、このような扱いとなっている。</p>

<p>とはいえ、仕様が古くなっている点も散見される。例えばノードの取得時に、JCR2.0では非推奨になっているUUIDを用いており、このような点は修正される必要がある。</p>

<p>2012年5月より、OCMの開発を再開する動きがでており、jackrabbit-ocmのtrunkコードベースはバージョン2.0-SNAPSHOTとなり、コードの更新が再開されている。</p>

<ul>
<li>JIRA: https://issues.apache.org/jira/browse/OCM</li>
<li>Svn:  http://svn.apache.org/viewvc/jackrabbit/commons/ocm/</li>
<li>Forked source on Github: https://github.com/k2n/jackrabbit-ocm</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeType First or Class First]]></title>
    <link href="http://k2n.github.com/blog/2012/05/29/nodetype-first-or-class-first/"/>
    <updated>2012-05-29T19:14:00-07:00</updated>
    <id>http://k2n.github.com/blog/2012/05/29/nodetype-first-or-class-first</id>
    <content type="html"><![CDATA[<p>SOAPによるWebService向けのAPIを開発する際、WSDLを先に宣言してコードを生成するWSDL Firstのアプローチか、コードからWSDLを生成するCode Firstかを、戦略として選択する必要がある。jackrabbit-ocmにおいても同様に、開発戦略の選択が求められる。</p>

<p>jackrabbit-ocmを用いてオブジェクトの永続化を行う際、二つのアプローチが考えられる。
一つは、class descirptorのdiscriminatorを規定値の<code>true</code>のままで用い、ObjectContentManagerがオブジェクトをインスタンス化する場合は、クラスに紐づけられたclass descriptorの定義情報を参照する方法である。</p>

<p>もうひとつは、まずノードタイプをXML、あるいは<a href="http://jackrabbit.apache.org/node-type-notation.html">CND</a>で定義し、そのノードタイプ定義に合わせて、ocmのclass descriptorをXMLまたはクラスのアノテーションとして定義する方法である。その際、class descriptorの<code>discriminator</code>フラグは<code>false</code>に設定し、ObjectContentMangerがオブジェクトをインスタンス化する際は、オブジェクトのclass descriptorではなく、ノードタイプのdescriptorが参照されることになる。</p>

<h2>discriminator=true</h2>

<p>一番目のアプローチの例として、<code>jackrabbit-ocm</code>プロジェクトのユニットテストで、<a href="https://github.com/k2n/jackrabbit-ocm/blob/master/src/test/java/org/apache/jackrabbit/ocm/manager/basic/AnnotationSimpleTest.java">AnnotateSimpleTest</a>を実行する。</p>

<p>永続クラス<code>A</code>は下記の通り。
``` java A.java https://github.com/k2n/jackrabbit-ocm/blob/master/src/test/java/org/apache/jackrabbit/ocm/manager/basic/AnnotationSimpleTest.java#L81
...
@Node(jcrMixinTypes="mix:lockable" )
public class A
{</p>

<pre><code>@Field(path=true) private String path;
@Field private String a1;
@Field private String a2;
@Bean(jcrType="nt:unstructured", jcrOnParentVersion="IGNORE") private B b;

private B emptyB;

@Collection(elementClassName=C.class, jcrType="nt:unstructured", jcrOnParentVersion="IGNORE") private java.util.Collection collection;
@Collection(elementClassName=C.class) private java.util.Collection emptyCollection;
</code></pre>

<p>...</p>

<p>```</p>

<p><code>A</code>クラスを永続化するテストコードの一部は下記の通り。
``` java AnnotationSimpleTest.java https://github.com/k2n/jackrabbit-ocm/blob/master/src/test/java/org/apache/jackrabbit/ocm/manager/basic/AnnotationSimpleTest.java#L81</p>

<pre><code>A a = new A();
a.setPath("/test");
a.setA1("a1");
a.setA2("a2");
B b = new B();
b.setB1("b1");
b.setB2("b2");
a.setB(b);

C c1 = new C();
c1.setId("first");
c1.setName("First Element");
C c2 = new C();
c2.setId("second");
c2.setName("Second Element");

C c3 = new C();
c3.setId("third");
c3.setName("Third Element");


Collection collection = new ArrayList();
collection.add(c1);
collection.add(c2);
collection.add(c3);

a.setCollection(collection);

ocm.insert(a);
ocm.save();
</code></pre>

<p>```</p>

<p>テスト実行後のリポジトリは下記のようになる。<code>discriminator</code>は真なので、<code>ocm_classname</code>プロパティにフルパッケージのクラス名が設定されていることに注意。 <code>C.java</code>はdiscriminator=falseのため、<code>ocm_classname</code>プロパティを持たず、代わりに<code>ocm:C</code>ノードタイプを指定している。</p>

<p>``` text
/test
+-properties
| +-jcr:mixinTypes: [mix:lockable]
| +-a2: 'a2'
| +-ocm_classname: 'org.apache.jackrabbit.ocm.testmodel.A'
| +-jcr:primaryType: nt:unstructured
| +-a1: 'new value'
+-children
  +-/test/b
  +-/test/collection</p>

<p>% cd b
/test/b
% ls
/test/b
+-properties
| +-b1: 'new B1'
| +-b2: 'new B2'
| +-jcr:primaryType: nt:unstructured
| +-ocm_classname: 'org.apache.jackrabbit.ocm.testmodel.B'
+-children</p>

<p>% cd ..
/test
% cd collection
/test/collection
% ls
/test/collection
+-properties
| +-jcr:primaryType: nt:unstructured
+-children
  +-/test/collection/first
  +-/test/collection/second
  +-/test/collection/third</p>

<p>% cd first
/test/collection/first
% ls
/test/collection/first
+-properties
| +-jcr:predecessors: [8f92077a-1780-41fb-85fd-67e1f69c0dd3 -> /jcr:system/jcr:versionStorage/3f/65/cb/3f65cbf7-cdda-444b-8411-91549bfdf61a/jcr:rootVersion]
| +-ocm:id: 'first'
| +-jcr:uuid: '3f65cbf7-cdda-444b-8411-91549bfdf61a'
| +-jcr:versionHistory: a49c277c-2a80-455f-b54c-e51feb744e38 -> /jcr:system/jcr:versionStorage/3f/65/cb/3f65cbf7-cdda-444b-8411-91549bfdf61a
| +-ocm:name: 'First Element'
| +-jcr:baseVersion: 8f92077a-1780-41fb-85fd-67e1f69c0dd3 -> /jcr:system/jcr:versionStorage/3f/65/cb/3f65cbf7-cdda-444b-8411-91549bfdf61a/jcr:rootVersion
| +-jcr:primaryType: ocm:C
| +-jcr:isCheckedOut: true
+-children
```</p>

<h2>discriminator=false</h2>

<p>二番目のアプローチの例として、<code>jackrabbit-ocm</code>プロジェクトのユニットテストより、<code>Page</code>クラスを引用する。
``` java Page.java https://github.com/k2n/jackrabbit-ocm/blob/master/src/test/java/org/apache/jackrabbit/ocm/testmodel/Page.java#L36
@Node(jcrType="ocm:page", discriminator=false)
public class Page
{</p>

<pre><code>@Field(path=true) String path;
@Field(jcrName="ocm:title") String title;

@Collection(collectionConverter=NTCollectionConverterImpl.class, jcrElementName="paragraph")
List&lt;Paragraph&gt; paragraphs;
</code></pre>

<p>...
}
<code>
このクラス定義にはすでにアノテーションでdescriptor情報が付加されているが、参考までに、XMLによる定義も載せる。
</code> xml jcmmapping.xml https://github.com/k2n/jackrabbit-ocm/blob/master/src/test/test-config/jcrmapping.xml#L86</p>

<pre><code>&lt;class-descriptor className="org.apache.jackrabbit.ocm.testmodel.Page" jcrType="ocm:page" discriminator="false" &gt;
    &lt;field-descriptor fieldName="path" path="true" /&gt;
    &lt;field-descriptor fieldName="title" jcrName="ocm:title" /&gt;
    &lt;collection-descriptor fieldName="paragraphs" proxy="false"
                           elementClassName="org.apache.jackrabbit.ocm.testmodel.Paragraph"
                       jcrElementName="paragraph"
                           collectionConverter="org.apache.jackrabbit.ocm.manager.collectionconverter.impl.NTCollectionConverterImpl" /&gt;
&lt;/class-descriptor&gt;
</code></pre>

<p><code>
このクラスがリポジトリに下記のコードで永続化する。
</code> java Page object persistence snippet</p>

<pre><code>        Page page = new Page();
        page.setPath("/test");
        page.setTitle("Page Title");

        List&lt;Paragraph&gt; paragraphs = new ArrayList&lt;Paragraph&gt;();

        paragraphs.add(new Paragraph("Para 1"));
        paragraphs.add(new Paragraph("Para 2"));
        paragraphs.add(new Paragraph("Para 3"));
        page.setParagraphs(paragraphs);

        ocm.insert(page);
        ocm.save();
</code></pre>

<p>```</p>

<p>永続化されたリポジトリ内の情報は以下の通り。Paragraphコレクションのコンバータとして、NTCollectionConverterImplが指定されているため、コレクションの要素であるParagraphクラスが、中間ノードの介在なしで、直接<code>test</code>の子要素として作成されていることに注目。<code>jcrElementName</code>が指定されているので、その値の<code>paragraph</code>（と添字）が要素名として使われている。</p>

<p>``` text
/test
+-properties
| +-jcr:predecessors: [f57d2a5f-4b92-4930-be0e-3ca21efa1b7d -> /jcr:system/jcr:versionStorage/d6/f5/fa/d6f5fad1-4dfc-4adb-8433-112666e31134/jcr:rootVersion]
| +-jcr:uuid: 'd6f5fad1-4dfc-4adb-8433-112666e31134'
| +-jcr:versionHistory: 16f4955c-77df-48b5-8836-77fb1ff10f2c -> /jcr:system/jcr:versionStorage/d6/f5/fa/d6f5fad1-4dfc-4adb-8433-112666e31134
| +-ocm:title: 'Page Title'
| +-jcr:baseVersion: f57d2a5f-4b92-4930-be0e-3ca21efa1b7d -> /jcr:system/jcr:versionStorage/d6/f5/fa/d6f5fad1-4dfc-4adb-8433-112666e31134/jcr:rootVersion
| +-jcr:isCheckedOut: true
| +-jcr:primaryType: ocm:page
+-children
  +-/test/paragraph
  +-/test/paragraph[2]
  +-/test/paragraph[3]</p>

<p>/test/paragraph
+-properties
| +-jcr:predecessors: [6175438a-b2d5-4458-b890-eb8e853b29c2 -> /jcr:system/jcr:versionStorage/7a/f7/0f/7af70f04-f6ad-4b04-9e0a-ad539c9c5499/jcr:rootVersion]
| +-ocm:text: 'Para 1'
| +-jcr:uuid: '7af70f04-f6ad-4b04-9e0a-ad539c9c5499'
| +-jcr:versionHistory: d54ddd1a-7ee7-42d6-a395-003026f7a491 -> /jcr:system/jcr:versionStorage/7a/f7/0f/7af70f04-f6ad-4b04-9e0a-ad539c9c5499
| +-jcr:baseVersion: 6175438a-b2d5-4458-b890-eb8e853b29c2 -> /jcr:system/jcr:versionStorage/7a/f7/0f/7af70f04-f6ad-4b04-9e0a-ad539c9c5499/jcr:rootVersion
| +-jcr:isCheckedOut: true
| +-jcr:primaryType: ocm:paragraph
+-children
```
また、ノードタイプ情報は下記のようになる。Class Descriptorの情報が一切含まれていなことに注目。</p>

<p>``` text
% ls
/jcr:system/jcr:nodeTypes/ocm:page
+-properties
| +-jcr:hasOrderableChildNodes: false
| +-jcr:isMixin: false
| +-jcr:nodeTypeName: ocm:page
| +-jcr:mixinTypes: []
| +-jcr:supertypes: [mix:versionable,nt:base]
| +-jcr:primaryType: nt:nodeType
+-children
  +-/jcr:system/jcr:nodeTypes/ocm:page/jcr:propertyDefinition
  +-/jcr:system/jcr:nodeTypes/ocm:page/jcr:childNodeDefinition</p>

<p>% ls                                                                                                                           [46/659]
/jcr:system/jcr:nodeTypes/ocm:page/jcr:propertyDefinition
+-properties
| +-jcr:requiredType: 'STRING'
| +-jcr:autoCreated: false
| +-jcr:multiple: false
| +-jcr:mixinTypes: []
| +-jcr:protected: false
| +-jcr:name: ocm:title
| +-jcr:mandatory: true
| +-jcr:valueConstraints: []
| +-jcr:primaryType: nt:propertyDefinition
| +-jcr:onParentVersion: 'COPY'
+-children</p>

<p>% ls
/jcr:system/jcr:nodeTypes/ocm:page/jcr:childNodeDefinition
+-properties
| +-jcr:requiredPrimaryTypes: [ocm:paragraph]
| +-jcr:autoCreated: false
| +-jcr:defaultPrimaryType: ocm:paragraph
| +-jcr:mixinTypes: []
| +-jcr:protected: false
| +-jcr:sameNameSiblings: true
| +-jcr:mandatory: false
| +-jcr:primaryType: nt:childNodeDefinition
| +-jcr:onParentVersion: 'COPY'
+-children
```</p>

<h1>使い分けの方針</h1>

<p><a href="https://github.com/k2n/jackrabbit-ocm/blob/master/src/main/resources/org/apache/jackrabbit/ocm/config/jackrabbit-ocm-1.5.dtd">Class Descriptor</a>と<a href="http://jackrabbit.apache.org/node-types.html">Node Type Definition</a>は重複した内容を多く含んでおり、両方の整合性を保つことは煩雑である。よって、jackrabbit-ocmを用いて開発する際は、まずどちらをマッピング情報の主たるソースとして利用するか決定する必要がある。</p>

<p>もしjackrabbit-ocmをオブジェクト永続化フレームワークと捉え、オブジェクトによるモデリングを行うのであれば、<code>discriminator</code>を真、jcrTypeは<code>nt:unstructured</code>（どちらも規定値なので明示的な指定は不要）を選択し、Class Descriptorによるマッピングを行えばよい。</p>

<p>一方、リポジトリに格納した情報を、OCMフレームワークを使わずに読み出したい場合は、ノードタイプを明示的に指定するアプローチが望ましいだろう。オブジェクトを保存して作成されるノードツリーはそれぞれ適切なノードタイプが付与され、OCMを意識する必要がない。OCMを使わずに、通常のJCR APIを用いてツリーを操作することも可能である。OCMフレームワークの外からノードやプロパティを変更した場合に懸念される、OCM側のキャッシュが不一致になる問題(stale cache)については、<a href="https://github.com/k2n/jackrabbit-ocm/blob/master/src/main/java/org/apache/jackrabbit/ocm/manager/impl/ObjectContentManagerImpl.java">ObjectContentManagerImpl</a>は<code>ObjectCache</code>のインスタンス（標準では<a href="https://github.com/k2n/jackrabbit-ocm/blob/master/src/main/java/org/apache/jackrabbit/ocm/manager/cache/impl/RequestObjectCacheImpl.java">RequestObjectCacheImpl.java</a>を用いているが、キャッシュは<code>getObject</code>メソッドのスコープ内のみで有効なため、問題を起こす可能性は非常に低い。また、同時更新の可能性を完全に排除する必要がある場合は、JCR2.0 17章で定義されているロックを使用するか、バージョン管理を行うことで問題を避ける事ができるはずである。</p>

<p><div><script src='https://gist.github.com/2839177.js?file='></script>
<noscript><pre><code>    public Object getObject(Class objectClass, String path) {
        try {
            if (!session.itemExists(path)) {
                return null;
            }
        } catch (RepositoryException e) {
            throw new org.apache.jackrabbit.ocm.exception.RepositoryException(&quot;Impossible to get the object at &quot; + path, e);
        }

        Object object = objectConverter.getObject(session, objectClass, path);
        requestObjectCache.clear();
        return object;

    }</code></pre></noscript></div>
</p>

<p><div><script src='https://gist.github.com/2839183.js?file='></script>
<noscript><pre><code>	public Object getObject(Session session, Class clazz, String path)
	{
		try {
			if (!session.itemExists(path)) {
				return null;
			}

			if (requestObjectCache.isCached(path))
		    {
		        return requestObjectCache.getObject(path);
		    }

			ClassDescriptor classDescriptor = getClassDescriptor(clazz);
...snip...
			
            Object object = ReflectionUtils.newInstance(classDescriptor.getClassName());

            if (! requestObjectCache.isCached(path))
            {
			  requestObjectCache.cache(path, object);
            }
...snip...
	}</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jackrabbit-ocm Class Descriptor]]></title>
    <link href="http://k2n.github.com/blog/2012/05/29/jackrabbit-ocm-class-descriptor/"/>
    <updated>2012-05-29T11:27:00-07:00</updated>
    <id>http://k2n.github.com/blog/2012/05/29/jackrabbit-ocm-class-descriptor</id>
    <content type="html"><![CDATA[<h1>Class Descriptor要素と属性</h1>

<p><a href="https://github.com/k2n/jackrabbit-ocm/blob/master/src/main/resources/org/apache/jackrabbit/ocm/config/jackrabbit-ocm-1.5.dtd">jackrabbit-ocm-1.5.dtd</a>に基づく。</p>

<h1>class-descriptor</h1>

<p>``` dtd XML
&lt;!ATTLIST class-descriptor</p>

<pre><code>className CDATA #REQUIRED            ==| クラス名
jcrType CDATA #IMPLIED               ==| プライマリーJCRノードタイプ、オプション、既定値はnt:unstructured
jcrSuperTypes CDATA #IMPLIED         ==| JCR親タイプ、オプション
jcrMixinTypes CDATA #IMPLIED         ==| JCR mix-inタイプ（カンマ区切りで複数指定）オプション
extend CDATA #IMPLIED                ==| 親クラス名、オプション
abstract (true|false) "false"        ==| 抽象クラスで階層マッピング内で使われている場合はtrue
interface (true|false) "false"       ==| インターフェースならtrue
discriminator (true|false) "true"    ==| マップされたノードがocm:discriminatorノードタイプを要求する場合はtrue。このタイプはocm_classnameプロパティを含む。
</code></pre>

<blockquote><p>```</p></blockquote>

<p>``` java Annotation
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Node {</p>

<pre><code>String jcrType() default "nt:unstructured";
String jcrSuperTypes() default "";
String jcrMixinTypes() default "";
// Define the extend setting in the mapping descriptor - Provide less flexibility if we use the java instrospection 
Class extend() default Object.class;

// Define the abstract setting in the mapping descriptor - Provide less flexibility if we use the java instrospection
boolean isAbstract() default false;
</code></pre>

<p>//   Define the inteface setting in the mapping descriptor - Provide less flexibility if we use the java instrospection</p>

<pre><code>boolean isInterface() default false;

// Discriminator is used when an object hierarchy tree is mapped into the same jcr node type
// TODO : try to drop it from the mapping strategy. it should be hidden in the persistence manager impl.
boolean discriminator() default true;
</code></pre>

<p>}
```</p>

<h2>使用例(XML)</h2>

<p>``` xml XML
<jackrabbit-ocm></p>

<pre><code>&lt;class-descriptor
    className="org.apache.jackrabbit.ocm.testmodel.Atomic" jcrType="nt:unstructured" discriminator="true" &gt;
    &lt;field-descriptor fieldName="path" path="true" /&gt;
    &lt;field-descriptor fieldName="string" jcrName="string" /&gt;
    &lt;field-descriptor fieldName="booleanObject" jcrName="booleanObject" /&gt;
</code></pre>

<p>...
```</p>

<h2>使用例(annotation)</h2>

<p>``` java Annotation
@Node(jcrType="ocm:page", discriminator=false)
public class Page
{</p>

<pre><code>@Field(path=true) String path;
@Field(jcrName="ocm:title") String title;

@Collection(collectionConverter=NTCollectionConverterImpl.class, jcrElementName="paragraph")
List&lt;Paragraph&gt; paragraphs;
</code></pre>

<p>...
```</p>

<h2>discriminator</h2>

<ul>
<li>discriminatorフラグが真であれば、<code>ObjectConverterImpl.java#getObject</code>で、<code>className</code>に紐付けられたclass descriptorによってオブジェクトがインスタンス化される。偽であれば、ノードタイプに紐付けられたclass descriptorによってインスタンス化される。その際、クラス名は、<code>ocm:discriminator</code>ノードタイプのプロパティ<code>ocm_classname</code>に保持されている値が用いられる。</li>
</ul>


<p>``` java ObjectConverterImpl.java
...</p>

<pre><code>/**
 *
 * @see org.apache.jackrabbit.ocm.manager.objectconverter.ObjectConverter#insert(javax.jcr.Session,
 *      javax.jcr.Node, java.lang.String, java.lang.Object)
 */
public void insert(Session session, Node parentNode, String nodeName, Object object) {
    ClassDescriptor classDescriptor = mapper.getClassDescriptorByClass(object.getClass());

       .....
        // If required, add the discriminator node type
        // discriminatorフラグがセットされていれば、
        if (classDescriptor.hasDiscriminator()) {
            // ocm_classnameをセット
            addDiscriminatorProperty(object, objectNode);
        }
       .....
}

private void addDiscriminatorProperty(Object object, Node objectNode)
        throws NoSuchNodeTypeException, VersionException,
        ConstraintViolationException, LockException, RepositoryException,
        ValueFormatException {

    try {
        // beanクラス名をセット
        objectNode.setProperty(ManagerConstant.DISCRIMINATOR_CLASS_NAME_PROPERTY,
                ReflectionUtils.getBeanClass(object).getName());

    } catch (Exception e) {
        // if it is not possible to add the CLASS_NAME_PROPERTY due to strong constraints in the
        // node type definition, try to add the Discriminator node type.
        String mixinTypeName;
        mixinTypeName = ManagerConstant.DISCRIMINATOR_NODE_TYPE;
        objectNode.addMixin(mixinTypeName);
        objectNode.setProperty(ManagerConstant.DISCRIMINATOR_CLASS_NAME_PROPERTY,
                ReflectionUtils.getBeanClass(object).getName());
    }

}
</code></pre>

<p>...</p>

<pre><code>/**
 * @see org.apache.jackrabbit.ocm.manager.objectconverter.ObjectConverter#getObject(javax.jcr.Session,
 *      java.lang.Class, java.lang.String)
 */
public Object getObject(Session session, String path) {
    try {
        if (!session.itemExists(path)) {
            return null;
        }

        if (requestObjectCache.isCached(path))
        {
            return requestObjectCache.getObject(path);
        }

        ClassDescriptor classDescriptor = null;
        Node node = (Node) session.getItem(path);
        // ocm_classname プロパティがあれば。。。
        if (node.hasProperty(ManagerConstant.DISCRIMINATOR_CLASS_NAME_PROPERTY)) {
            String className = node.getProperty(ManagerConstant.DISCRIMINATOR_CLASS_NAME_PROPERTY).getValue().getString();
            // class名に基づいたdescriptorを取得
            classDescriptor = mapper.getClassDescriptorByClass(ReflectionUtils.forName(className));
        } else {
            // そうでなければ、node typeを基にdescriptorを取得
            String nodeType = node.getPrimaryNodeType().getName();
            if (nodeType.equals(ManagerConstant.FROZEN_NODE_TYPE)) {
                nodeType = node.getProperty(ManagerConstant.FROZEN_PRIMARY_TYPE_PROPERTY).getString();
            }
            classDescriptor = mapper.getClassDescriptorByNodeType(nodeType);
        }

        if (null == classDescriptor) {
            throw new JcrMappingException("Impossible to find the classdescriptor for " + path
                    + ". There is no discriminator and associated  JCR node type");
        }

        Object object = ReflectionUtils.newInstance(classDescriptor.getClassName());
</code></pre>

<p>...
```</p>

<ul>
<li>参考：<code>ocm:discriminator</code>のノードタイプ定義
``` xml custom_nodetypes.xml https://github.com/k2n/jackrabbit-ocm/blob/master/src/test/test-config/nodetypes/custom_nodetypes.xml
 <nodeType name="ocm:discriminator" isMixin="true">
  <supertypes>

<pre><code>&lt;supertype&gt;nt:base&lt;/supertype&gt;
</code></pre>

<p>  </supertypes>
  <propertyDefinition name="ocm_classname" requiredType="String" autoCreated="false" mandatory="true" onParentVersion="COPY" protected="false" multiple="false" />  <br/>
</nodeType>
```</p></li>
</ul>


<h3>例：Paragraphクラス</h3>

<ul>
<li>Paragraphクラスの定義では、discriminatorがfalseに設定されているので、オブジェクトをリポジトリから取得する場合は、<code>ocm:paragraph</code>タイプのdescriptor情報を基にインスタンス化される。</li>
</ul>


<p>``` xml jcrmapping-sibling.xml</p>

<pre><code>&lt;class-descriptor className="org.apache.jackrabbit.ocm.testmodel.Paragraph" jcrType="ocm:paragraph" discriminator="false" &gt;
    &lt;field-descriptor fieldName="path" path="true" /&gt;
    &lt;field-descriptor fieldName="text" jcrName="ocm:text"/&gt;
&lt;/class-descriptor&gt;
</code></pre>

<p>```</p>

<p>``` xml custom_nodetypes.xml
  <nodeType name="ocm:paragraph" isMixin="false" hasOrderableChildNodes="false" primaryItemName=""></p>

<pre><code>&lt;supertypes&gt;
  &lt;supertype&gt;mix:versionable&lt;/supertype&gt;
  &lt;supertype&gt;nt:base&lt;/supertype&gt;
&lt;/supertypes&gt;
&lt;propertyDefinition name="ocm:text" requiredType="String" autoCreated="false" mandatory="true" onParentVersion="COPY" protected="false" multiple="false" /&gt;
</code></pre>

<p>  </nodeType></p>

<p>```</p>

<h1>implement-descriptor</h1>

<p>``` dtd implement-descriptor
&lt;!ATTLIST implement-descriptor</p>

<pre><code>interfaceName CDATA #REQUIRED   ==| フルパッケージ付きクラス名
</code></pre>

<blockquote><p>```</p></blockquote>

<h2>例(XML)</h2>

<p>``` xml</p>

<pre><code>&lt;class-descriptor className="org.apache.jackrabbit.ocm.testmodel.auto.impl.CmsObjectImpl" jcrType="ocm:cmsobjectimpl"  
                                   discriminator="false" abstract="true" &gt;
    &lt;implement-descriptor interfaceName="org.apache.jackrabbit.ocm.testmodel.auto.CmsObject" /&gt;                                         
</code></pre>

<p><code>       
* `implement-descriptor`を持つ`CmsObjectImpl`のクラスシグネチャ。`CmsObject`インターフェースをimplementしている。
</code> java CmsObjectImpl Signature
@Node(jcrType="ocm:cmsobjectimpl", discriminator=false, isAbstract=true)
public abstract class CmsObjectImpl implements CmsObject
{</p>

<pre><code>@Field(path=true) protected String path;
</code></pre>

<p>...
```</p>

<h1>field-descriptor</h1>

<p>``` dtd field-descriptor
&lt;!ATTLIST field-descriptor</p>

<pre><code>fieldName CDATA #REQUIRED                  ==| フィールド名
jcrName CDATA #IMPLIED                     ==| JCRプロパティ名。省略された場合はfieldNameが使用される
id (true | false) "false"                  ==| 本フィールドがIdならば真
path (true | false) "false"                ==| 本フィールドがノードのpathを示しているのであれば真
uuid (true | false) "false"                ==| 本フィールドがUUIDを示しているのであれば真。JCR2.0ではUUIDの使用は非推奨
converter CDATA #IMPLIED                   ==| AtomicTypeConvertクラス名。指定されなければフィールドタイプの標準コンバータを使用
jcrDefaultValue CDATA #IMPLIED             ==| フィールドがnullの場合に用いられる規定値
jcrValueConstraints CDATA #IMPLIED         ==| カンマ区切りの許容される値のリスト
jcrType (String | Date | Long | Doube | Boolean | Binary) #IMPLIED ==| JCRプロパティタイプ、オプション
jcrAutoCreated (true | false) "false"      ==| 親オブジェクトインスタンス生成時に自動作成されるか否か
jcrMandatory (true | false) "false"        ==| JCRプロパティが必須かどうか
jcrOnParentVersion (COPY | VERSION | INITIALIZE | COMPUTE | IGNORE | ABORT) "COPY" ==| 親オブジェクトがバージョン管理され場合の振舞い
jcrProtected (true | false) "false"        ==| このJCRノードプロパティが保護されるか否か
jcrMultiple (true | false) "false"         ==| このJCRノードプロパティが複数値を取れるか否か
</code></pre>

<blockquote><p>```</p></blockquote>

<h1>bean-descriptor</h1>

<p>``` dtd bean-descriptor
&lt;!ELEMENT bean-descriptor EMPTY>
&lt;!ATTLIST bean-descriptor</p>

<pre><code>fieldName CDATA #REQUIRED              ==| フィールド名
jcrName CDATA #IMPLIED                 ==| JCRノード名。省略された場合はfieldNameが用いられる。
proxy (true | false) "false"           ==| 真の場合、親オブジェクトのインスタンス化時にはロードされず、アクセス時に初めてローディングされる。
autoRetrieve (true|false) "true"       ==| 偽の場合、親オブジェクトが取得された場合にもこのdescriptorを持つbeanは取得されない。
autoUpdate (true|false) "true"         ==| 偽の場合、親オブジェクトが更新された場合にも更新されない。
autoInsert (true|false) "true"         ==| 偽の場合、親オブジェクトが挿入された場合にも更新されない。
converter CDATA #IMPLIED               ==| Converterクラスの古パッケージクラス名。規定値はObjectConverterImpl。
jcrType CDATA #IMPLIED                 ==| ノードタイプ。オプション。規定値はnt:unstructured
jcrAutoCreated (true | false) "false"  ==| 親オブジェクトが作成された際に自動的に作成されるかどうか。JCR2.0 3.7.2.3 
jcrMandatory (true | false) "false"    ==| 親オブジェクトがsaveされる前に作成されていなければならない。JCR2.0 3.7.2.4
jcrOnParentVersion (COPY | VERSION | INITIALIZE | COMPUTE | IGNORE | ABORT) "COPY" ==| 親オブジェクトがバージョン管理された場合の振舞い。
jcrProtected (true | false) "false"    ==| 真の場合、削除不可、子要素は挿入、削除、順序変更不可、プロパティ追加削除不可、既存のpロパティ値の変更不可、主ノードタイプの変更不可、mixinノードタイプの追加削除不可。 3.7.2.2
jcrSameNameSiblings (true | false) "false" ==| 同名ノードの許可。3.1.3.1
</code></pre>

<blockquote><p>```</p></blockquote>

<h1>collection-descriptor</h1>

<p>``` dtd collection-descriptor
&lt;!ATTLIST collection-descriptor</p>

<pre><code>fieldName CDATA #REQUIRED             ==| フィールド名。この値は一部のconverterでのみ用いられる。
jcrName CDATA #IMPLIED                ==| JCRプロパティ名。指定されない場合はfieldNameが用いられる。
proxy (true | false) "false"          ==| 真の場合、遅延ローディングされ、親オブジェクトの生成時にはロードされない。
autoRetrieve (true|false) "true"      ==| 偽の場合、親オブジェクトが取得された時点でも取得されない。
autoUpdate (true|false) "true"        ==| 偽の場合、親オブジェクトが更新されても更新されない。
autoInsert (true|false) "true"        ==| 偽の場合、親オブジェクトが挿入されても挿入されない。
elementClassName CDATA #IMPLIED       ==| 永続コレクションの要素クラスのフルパッケージ名。
collectionClassName CDATA #IMPLIED    ==| Java Collectionクラスのフルパッケージクラス名。
collectionConverter CDATA #IMPLIED    ==| コレクションマッピングストラテジーを制御する、converterのクラス名。規定値はDefaultCollectionConverterImpl。
jcrElementName CDATA #IMPLIED         ==| コレクションの個々の要素に割り当てたいJCRノード名
jcrType CDATA #IMPLIED                ==| コレクション要素のJCRタイプ。
jcrAutoCreated (true | false) "false" ==| 親オブジェクト生成時に自動生成されるか  
jcrMandatory (true | false) "false"   ==| 親オブジェクトがsaveされる前に存在していなければならないかどうか
jcrOnParentVersion (COPY | VERSION | INITIALIZE | COMPUTE | IGNORE | ABORT) "COPY" ==| 親オブジェクトがバージョン管理された場合の振舞い。
jcrProtected (true | false) "false"  ==| このコレクションが保護されるかどうか。
jcrSameNameSiblings (true | false) "false"  ==| 同名を許可するか否か
</code></pre>

<blockquote><p>```</p></blockquote>

<h1>Converter</h1>

<h2>Atomic</h2>

<p><div><script src='https://gist.github.com/2822695.js?file='></script>
<noscript><pre><code>@Node
public class Atomic
{	
	@Field(path=true) protected String path;
	@Field private String string;
	@Field private Boolean booleanObject;
	@Field private boolean booleanPrimitive;
	@Field private Integer integerObject;
	@Field private int intPrimitive;
	@Field private byte[] byteArray;
	@Field private Calendar calendar;
	@Field private Date date;
	@Field private Double doubleObject;
	@Field private double doublePrimitive;
	@Field private InputStream inputStream;
	@Field private Timestamp timestamp;
	
	@Field (converter = Int2BooleanTypeConverterImpl.class)
	private boolean int2boolean;

	@Field (converter = NameTypeConverterImpl.class)
    private String namedProperty;

    @Field (converter = PathTypeConverterImpl.class)
    private String pathProperty; // used to refer another node

    @Field (converter = UndefinedTypeConverterImpl.class)
    private Object undefinedProperty;
</code></pre></noscript></div>
</p>

<h2>Atomic Type Converter</h2>

<h3>インターフェース</h3>

<p> <div><script src='https://gist.github.com/2822741.js?file='></script>
<noscript><pre><code>package org.apache.jackrabbit.ocm.manager.atomictypeconverter;

import javax.jcr.Value;
import javax.jcr.ValueFactory;

/**
 *
 * AtomicTypeConverter interface.
 *
 * The Object converter used atomic type converters to map atomic fields to JCR Value objects.
 * Amotic fields are primitive java types and their wrapper classes.
 *
 *
 * @author &lt;a href=&quot;mailto:christophe.lombart@sword-technologies.com&quot;&gt;Christophe Lombart&lt;/a&gt;
 * @author &lt;a href='mailto:the_mindstorm[at]evolva[dot]ro'&gt;Alexandru Popescu&lt;/a&gt;
 */
public interface AtomicTypeConverter
{
	/**
	 * Convert an object into a JCR value.
	 *
     * @param valueFactory The JCR ValueFactory
	 * @param object The object to convert
	 * @return the corresponding JCR value
	 *
	 */
	public Value getValue(ValueFactory valueFactory, Object object);

	/**
	 * Convert a jcr property value into an object
	 *
	 * @param value The JCR property value
	 * @return the corresponding object	
	 */
	public Object getObject(Value value);
	
	/**
	 * Get the string converted value. This is mainly used to build xpath expressions
	 *
	 * @param valueFactory The JCR ValueFactory
	 * @param object The object value
	 * @return The string converted value	
	 */
	public String getXPathQueryValue(ValueFactory valueFactory, Object object);
}
</code></pre></noscript></div>
</p>

<h3>実装例</h3>

<p> <div><script src='https://gist.github.com/2822770.js?file='></script>
<noscript><pre><code>package org.apache.jackrabbit.ocm.manager.atomictypeconverter.impl;

import javax.jcr.PropertyType;
import javax.jcr.RepositoryException;
import javax.jcr.Value;
import javax.jcr.ValueFactory;

import org.apache.jackrabbit.ocm.exception.IncorrectAtomicTypeException;
import org.apache.jackrabbit.ocm.manager.atomictypeconverter.AtomicTypeConverter;

/**
 *
 *  Name Type Converter
 *
 * @author &lt;a href=&quot;mailto:christophe.lombart@gmail.com&quot;&gt;Christophe Lombart&lt;/a&gt;
 *
 */
public class PathTypeConverterImpl implements AtomicTypeConverter
{
	/**
	 *
	 * @see org.apache.jackrabbit.ocm.manager.atomictypeconverter.AtomicTypeConverter#getValue(java.lang.Object)
	 */
	public Value getValue(ValueFactory valueFactory, Object propValue)
	{
		try
		{
			if (propValue == null)
			{
				return null;
			}
			return valueFactory.createValue((String) propValue, PropertyType.PATH);
		}
		catch (RepositoryException e)
		{
			throw new IncorrectAtomicTypeException(&quot;Impossible to convert the value into a path property : &quot; + propValue.toString() + &quot;. Check if it is a valid path.&quot;, e);
		}
		
	}

    /**
     *
     * @see org.apache.jackrabbit.ocm.manager.atomictypeconverter.AtomicTypeConverter#getObject(javax.jcr.Value)
     */
	public Object getObject(Value value)
    {
		try
		{
			return value.getString();
		}
		catch (RepositoryException e)
		{
			throw new IncorrectAtomicTypeException(&quot;Impossible to convert the path into a string&quot;, e);
		}

	}
	
	/**
	 *
	 * @see org.apache.jackrabbit.ocm.manager.atomictypeconverter.AtomicTypeConverter#getStringValue(java.lang.Object)
	 */
	public String getXPathQueryValue(ValueFactory valueFactory, Object object)
	{
		return &quot;'&quot; + object.toString() + &quot;'&quot;;
	}
}
</code></pre></noscript></div>
</p>

<h2>Bean Converter</h2>

<p> <div><script src='https://gist.github.com/2829877.js?file='></script>
<noscript><pre><code>package org.apache.jackrabbit.ocm.manager.beanconverter;


import javax.jcr.Node;
import javax.jcr.Session;

import org.apache.jackrabbit.ocm.exception.JcrMappingException;
import org.apache.jackrabbit.ocm.exception.ObjectContentManagerException;
import org.apache.jackrabbit.ocm.exception.RepositoryException;
import org.apache.jackrabbit.ocm.manager.beanconverter.impl.ParentBeanConverterImpl;
import org.apache.jackrabbit.ocm.mapper.model.BeanDescriptor;
import org.apache.jackrabbit.ocm.mapper.model.ClassDescriptor;

/**
 * Interface describing a custom bean converter.
 *
 * @author &lt;a href='mailto:the_mindstorm[at]evolva[dot]ro'&gt;Alexandru Popescu&lt;/a&gt;
 */
public interface BeanConverter {
	
	
    /**
     * Insert the object.
     *
     * @param session the JCR session
     * @param parentNode The node which will contain the converter bean
     * @param beanDescriptor The bean descriptor
     * @param beanClassDescriptor the Class Descriptor associated to the bean to insert
     * @param bean the bean to convert( insert into the JCR structure)
     * @param parentClassDescriptor The Class Descriptor associated to the parent object
     * @param parent the object which will contain the bean to convert
     *
     * @throws ObjectContentManagerException thrown in case the insert fails; marks a failure due to logic of
     *  the insert (parent node cannot be accessed, the insert fails, etc.)
     * @throws RepositoryException thrown in case the underlying repository has thrown a
     *  &lt;code&gt;javax.jcr.RepositoryException&lt;/code&gt; that is not possible to be handled or
     *  wrapped in ObjectContentManagerException; marks a repository failure
     * @throws JcrMappingException throws in case the mapping of the bean is not correct
     */
    void insert(Session session, Node parentNode, BeanDescriptor beanDescriptor, ClassDescriptor beanClassDescriptor, Object bean, ClassDescriptor parentClassDescriptor, Object parent)
    throws ObjectContentManagerException, RepositoryException, JcrMappingException;

    /**
     * Update repository from bean values.
     *
     * @param session the JCR session
     * @param parentNode The node which will contain the converter bean
     * @param beanDescriptor The bean descriptor
     * @param beanClassDescriptor the Class Descriptor associated to the bean to update
     * @param bean the bean to convert( insert into the JCR structure)
     * @param parentClassDescriptor The Class Descriptor associated to the parent object
     * @param parent the object which will contain the bean to convert
     *
     * @throws ObjectContentManagerException thrown in case the update fails; marks a failure due to logic
     *  of update (parent node cannot be accessed, the update fails, etc.)
     * @throws RepositoryException thrown in case the underlying repository has thrown a
     *  &lt;code&gt;javax.jcr.RepositoryException&lt;/code&gt; that is not possible to be handled or
     *  wrapped in ObjectContentManagerException; marks a repository failure
     * @throws JcrMappingException throws in case the mapping of the bean is not correct
     */
    void update(Session session, Node parentNode, BeanDescriptor beanDescriptor, ClassDescriptor beanClassDescriptor, Object bean, ClassDescriptor parentClassDescriptor, Object parent)
    throws ObjectContentManagerException, RepositoryException, JcrMappingException;

    /**
     * Retrieve a bean from the repository.
     *
     * @param session the JCR session
     * @param parentNode The parent node
     * @param beanDescriptor The bean descriptor
     * @param beanClassDescriptor the Class Descriptor associated to the bean to insert
     * @param beanClass The bean Class
     * @param parent The parent which contain the bean to retrieve
     *
     * @throws ObjectContentManagerException thrown in case the bean cannot be retrieved or initialized;
     *  marks a failure due to logic of retrieval
     * @throws RepositoryException thrown in case the underlying repository has thrown a
     *  &lt;code&gt;javax.jcr.RepositoryException&lt;/code&gt; that is not possible to be handled or
     *  wrapped in ObjectContentManagerException; marks a repository failure
     * @throws JcrMappingException throws in case the mapping of the bean is not correct
     */
    Object getObject(Session session, Node parentNode, BeanDescriptor beanDescriptor, ClassDescriptor beanClassDescriptor, Class beanClass, Object parent)
    throws ObjectContentManagerException, RepositoryException, JcrMappingException;


    /**
     * Remove the bean from the repository.
     *
     * @param session the JCR session
     * @param parentNode The node which will contain the converter bean
     * @param beanDescriptor The bean descriptor
     * @param beanClassDescriptor the Class Descriptor associated to the bean to update
     * @param bean the bean to convert( insert into the JCR structure)
     * @param parentClassDescriptor The Class Descriptor associated to the parent object
     * @param parent the object which contains the bean to convert
     *
     * @throws ObjectContentManagerException thrown in case the bean cannot be removed;
     *  marks a failure due to logic of removal
     * @throws RepositoryException thrown in case the underlying repository has thrown a
     *  &lt;code&gt;javax.jcr.RepositoryException&lt;/code&gt; that is not possible to be handled or
     *  wrapped in ObjectContentManagerException; marks a repository failure
     * @throws JcrMappingException throws in case the mapping of the bean is not correct
     */
    void remove(Session session, Node parentNode,  BeanDescriptor beanDescriptor, ClassDescriptor beanClassDescriptor, Object bean, ClassDescriptor parentClassDescriptor, Object parent)
    throws ObjectContentManagerException, RepositoryException, JcrMappingException;

    /**
     * Get the bean path.
     *
     * When the bean is mapped to a subnode, the bean path is the parent node path + the jcrname of the current bean.
     * Sometime a BeanConverter can be used to access to a bean which is not mapped to a subnode. In this case,
     * another implementation can be provided in this method getPath. {@link  ParentBeanConverterImpl} is a good example.
     *
     * @param session the JCR session
     * @param beanDescriptor The descriptor of the bean to convert
     * @param parentNode the node which contain this bean (its corresponfing subnode)
     * @return the bean path
     *
     * @throws RepositoryException thrown in case the underlying repository has thrown a
     *  &lt;code&gt;javax.jcr.RepositoryException&lt;/code&gt; that is not possible to be handled or
     *  wrapped in ObjectContentManagerException; marks a repository failure
     *
     */
    String getPath(Session session, BeanDescriptor beanDescriptor, Node parentNode)
    throws ObjectContentManagerException;


}
</code></pre></noscript></div>
</p>

<h2>Collection Converters</h2>

<h3>BeanReferenceCollectionConverterImpl</h3>

<p>Reference/uuidのプロパティリストをJavaコレクションにマップするために用いられる。</p>

<h3>BeanReferenceMapConverterImpl</h3>

<p>Reference/uuidのプロパティをjava.util.Mapにマップする。キーはStringであることが前提で、Map&lt;Object,Object>はサポートされていない。</p>

<h3>DefaultCollectionConverterImpl</h3>

<p><code>jcrName</code>で指定された名称で作られた中間JCRノードの下にコレクションをマップする戦略である。これは<code>nt:unstractured</code>をコレクション要素に適用したい場合に便利である。これにより、コレクション要素と、親オブジェクトの他のフィールドと区別することができるようになる。 コレクション要素のクラスがIdフィールドを持っている場合、そのId値がコレクション要素を構築する際に用いられる。そうでない場合は要素のノード名は定数が用いられる。</p>

<p>``` text Id属性の指定なしの場合
   /test (コレクションフィールドを持つ親オブジェクト)</p>

<pre><code> /mycollection (コレクション全体を格納するための中間ノード)
      /collection-element (コレクションの第一要素を格納するためのノード)
            /item-prop
            ....
      /collection-element (コレクションの第二要素を格納するためのノード)
      ...
</code></pre>

<p>```</p>

<p>``` text Id属性指定ありの場合
   /test (コレクションフィールドを持つ親オブジェクト)</p>

<pre><code> /mycollection (コレクション全体を格納するための中間ノード)
      /aValue (最初の要素で指定されたIdの値を利用)
            /item-prop
            ....
      /anotherValue (二番目の要素で指定されたIdの値を利用)
      ...
</code></pre>

<p>```</p>

<h3>EnumCollectionConverterImpl</h3>

<p>Enum（列挙型）用のコンバータ。JCRのmulti valueプロパティを利用している。</p>

<h3>MultiValueCollectionConverterImpl</h3>

<p>JCR multi value プロパティに格納するコンバータ</p>

<h3>NTCollectionConverterImpl</h3>

<p>ノードタイプに基づいて、同じノードタイプをまとめてサブノードに格納する戦略。
このコンバータを使うにあたっては、以下の３つの制約がある。</p>

<ol>
<li>要素に同じJCRノードタイプを持つコレクションを二つ親オブジェクトに持つことはできない。</li>
<li>空のコレクションとNullコレクションの区別はできない。</li>
<li>Mapはサポートされない。</li>
</ol>


<p>``` text Id属性が指定されていない場合
   /test (コレクションフィールドを持つ親オブジェクト)</p>

<pre><code>      /collection-element (コレクションの第一要素を格納するためのノード)
            /item-prop
            ....
      /collection-element (コレクションの第二要素を格納するためのノード)
      ...
</code></pre>

<p><code>``
*</code>collection-element`ノードは全て同じJCRノードタイプであること</p>

<p>``` text Id属性が指定されている場合
   /test (コレクションフィールドを持つ親オブジェクト)</p>

<pre><code>      /aValue (最初の要素で指定されたIdの値を利用)
            /item-prop
            ....
      /anotherValue (二番目の要素で指定されたIdの値を利用)
      ...
</code></pre>

<p>```
* コレクション要素ノードは全て同じJCRノードタイプであること</p>

<h3>ReferenceCollectionConverterImpl</h3>

<p>Stringのコレクションを、１つのJCR multi valueプロパティに格納するコンバータ。</p>

<h3>ResidualNodesCollectionConverterImpl</h3>

<p>複数の子ノードを、<code>Node.getNodes(String pattern)</code>で取得してコレクションに変換するコンバータ。</p>

<h3>ResidualPropertiesCollectionConverterImpl</h3>

<p>複数のプロパティを、<code>Node.getProperties(String patter)</code>で取得し、コレクションに変換するコンバータ。</p>
]]></content>
  </entry>
  
</feed>
